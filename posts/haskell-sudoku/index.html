<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Haskell Sudoku | Blog | Upendra Upadhyay</title><meta name=keywords content="first"><meta name=description content="Desc Text."><meta name=author content="Upendra Upadhyay"><link rel=canonical href=https://canonical.url/to/page><meta name=google-site-verification content="G-10K1DEGGW1"><link crossorigin=anonymous href=/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://upendra1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://upendra1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://upendra1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://upendra1997.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://upendra1997.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-10K1DEGGW1"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-10K1DEGGW1",{anonymize_ip:!1})}</script><meta property="og:title" content="Haskell Sudoku"><meta property="og:description" content="Desc Text."><meta property="og:type" content="article"><meta property="og:url" content="https://upendra1997.github.io/posts/haskell-sudoku/"><meta property="og:image" content="https://upendra1997.github.io/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-29T11:14:10+05:30"><meta property="article:modified_time" content="2022-11-29T11:14:10+05:30"><meta property="og:site_name" content="Upendra - Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://upendra1997.github.io/%3Cimage%20path/url%3E"><meta name=twitter:title content="Haskell Sudoku"><meta name=twitter:description content="Desc Text."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://upendra1997.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Haskell Sudoku","item":"https://upendra1997.github.io/posts/haskell-sudoku/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Haskell Sudoku","name":"Haskell Sudoku","description":"Desc Text.","keywords":["first"],"articleBody":"Last time, I mentioned that I tried to write sudoku solver in haskell and it was using too much memory and time. So I tried to solve it again and this time I was able to do it, I guess I just needed more motivation.\nWe will be using this file format as input to our suodku program:\n92634.7.1 .5..264.9 .7.8.1... ...9..2.7 342.....5 1.....8.. 6854...12 ..4..29.. .1.538.7. and it will be represented as an array of numbers and . will be represented as 0, so for our repl, the sudoku will be [[Int]]\n[[9, 2, 6, 3, 4, 0, 7, 0, 1], [0, 5, 0, 0, 2, 6, 4, 0, 9], [0, 7, 0, 8, 0, 1, 0, 0, 0], [0, 0, 0, 9, 0, 0, 2, 0, 7], [3, 4, 2, 0, 0, 0, 0, 0, 5], [1, 0, 0, 0, 0, 0, 8, 0, 0], [6, 8, 5, 4, 0, 0, 0, 1, 2], [0, 0, 4, 0, 0, 2, 9, 0, 0], [0, 1, 0, 5, 3, 8, 0, 7, 0]] above sudoku only have one solution, but there could be sudokus with multiple solutions also, like:\n[[2, 9, 5, 7, 4, 3, 8, 6, 1], [4, 3, 1, 8, 6, 5, 9, 0, 0], -- 2 7 [8, 7, 6, 1, 9, 2, 5, 4, 3], [3, 8, 7, 4, 5, 9, 2, 1, 6], [6, 1, 2, 3, 8, 7, 4, 9, 5], [5, 4, 9, 2, 1, 6, 7, 3, 8], [7, 6, 3, 5, 2, 4, 1, 8, 9], [9, 2, 8, 6, 7, 1, 3, 5, 4], [1, 5, 4, 9, 3, 8, 6, 0, 0]] -- 7 2 or we could have empty sudoku, which will give us all the valid sudokus possible in the world:\n[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]] Project Structure This is created by using stack new suokdu\n. ├── CHANGELOG.md ├── LICENSE ├── README.md ├── Setup.hs ├── app │ └── Main.hs ├── emptySudoku.txt -- empty sudoku input file. ├── package.yaml ├── src │ └── Lib.hs ├── stack.yaml ├── stack.yaml.lock ├── sudoku.cabal ├── sudoku.txt -- only one solution sudoku file. └── test └── Spec.hs Defining Types here we will be defining a few of the types which will be used in our program, all of them are type aliases type instead of newtype as I wanted to use these types interchangeably with generic functions like crossProduct, which we will see later.\n-- src/Lib.hs type Cell = Int type SudokuSize = Int type Row = [Int] type X = Int type Y = Int type Coord = (X, Y) -- Coordinates type Sudoku = [Row] Config We will be storing some configs like sudokuSize and the gridSize in the Sudoku in the Lib.hs file.\n-- src/Lib.hs sudokuSize :: SudokuSize sudokuSize = 9 blockSize :: Int blockSize = 3 Parsing and printing Sudoku We need to pretty print our sudoku in the terminal, so for that, we will be defining showSudoku function:\n-- src/Lib.hs showRow :: Show a =\u003e [a] -\u003e String showRow row = unwords $ show \u003c$\u003e row showSudoku :: Show a =\u003e [[a]] -\u003e String showSudoku sudoku = unlines $ showRow \u003c$\u003e sudoku and to parse our sudoku from the file we will define below the functions:\n-- app/main.hs module Main (main) where import Data.Char (digitToInt) import Control.Monad (replicateM) import Lib (Cell, Row, sudokuSize, showSudoku) parseChar :: Char -\u003e Cell parseChar '.' = 0 parseChar x = digitToInt x parseString :: String -\u003e Row parseString = map parseChar readRow :: IO Row readRow = do row \u003c- parseString \u003c$\u003e getLine if length row /= sudokuSize then error \"row does not have the correct number of cells\" else return row main :: IO () main = do sudoku \u003c- replicateM sudokuSize readRow mapM_ (putStrLn . showSudoku) [sudoku] We have defined a function readRow which will read from stdin and try to parse it as a Row, and since readRow is an IO, i.e. it reads from the terminal, we can use replicateM to repeat this operation and read multiple rows from the terminal.\nif we look at the type of replicateM in the stack repl, we will see that:\nghci\u003e :t replicateM replicateM :: Applicative m =\u003e Int -\u003e m a -\u003e m [a] so here (Int -\u003e m a) -\u003e m [a] means that it will collect a from m type of computation and will return a new computation m [a] where all the a have been gathered from different computations. i.e. so here (9 -\u003e readRow) replicateM needs a number 9 and a computation to replicate which is readRow, and it will return IO [Row] which is a sudoku.\nsimilarly in MapM function, where _ will ignore the result:\nghci\u003e :t mapM mapM :: (Traversable t, Monad m) =\u003e (a -\u003e m b) -\u003e t a -\u003e m (t b) ghci\u003e :t mapM_ mapM_ :: (Foldable t, Monad m) =\u003e (a -\u003e m b) -\u003e t a -\u003e m () Validate Sudokus for a sudoku to be valid, each row and column must contain a number from 1 to 9 exactly once; and also there are 9 grids of size 3x3 in a 9x9 sudoku, where no number must repeat.\nget all rows -- src/lib.hs rows :: [[a]] -\u003e [[[a]]] rows = fmap (replicate sudokuSize) get all columns -- src/lib.hs columns :: [[a]] -\u003e [[[a]]] columns = transpose . rows . transpose get all grid blocks to get all grid blocks we need to know which grid each element of sudoku belongs to, every grid has a start and end position which can be represented by Coord type.\nCoordinates of all elements in sudoku:\n-- src/lib.hs coordinates :: [[Coord]] coordinates = [[(r, c) | c \u003c- [0 .. sudokuSize - 1]] | r \u003c- [0 .. sudokuSize - 1]] block coordinate will give us the start and end position pairs of all sudoku elements.\n-- src/lib.hs blockCoordinates :: [[(Coord, Coord)]] blockCoordinates = (fmap . fmap) (\\(x, y) -\u003e (start x y, end x y)) coordinates where start x' y' = (3 * (x' `div` blockSize), 3 * (y' `div` blockSize)) end x' y' = (\\(x'', y'') -\u003e (x'' + blockSize, y'' + blockSize)) $ start x' y' if Sudoku type was parametrized like:\ntype Sudoku a = [[a]] then we could have represented blockCoordinates as:\ntype Rectangle = (Coord, Coord) -- (start, end) blockCoordinates :: [[Rectangle]] to get values from block coordinates we need a few helper functions like slice and slice2D\n-- src/lib.hs slice :: Int -\u003e Int -\u003e [a] -\u003e [a] slice start end = drop start . take end -- src/lib.hs slice2D :: [[a]] -\u003e Int -\u003e Int -\u003e Int -\u003e Int -\u003e [[a]] slice2D sudoku startRow endRow startCol endCol = slice startRow endRow $ slice startCol endCol \u003c$\u003e sudoku and finally, our function to get blocks at each coordinate:\n-- src/lib.hs blocks :: Sudoku -\u003e [[[[Int]]]] blocks sudoku = (fmap . fmap) block blockCoordinates where getSlice = slice2D sudoku block ((startRow, startCol), (endRow, endCol)) = getSlice startRow endRow startCol endCol to understand it better, lets take our previous case where Sudoku was parametrized, which would give us\nblocks :: Sudoku -\u003e Sudoku (Sudoku Int) here blocks is like a sudoku of sudokus, where inner sudoku is a 3x3 grid.\nfinally, we merge all the values of the rows, column and grid values at each coordinate of the grid and we get:\n-- src/lib.hs getAllValues :: Sudoku -\u003e [[[Cell]]] getAllValues sudoku = (fmap . fmap) (sort . nub) all' where add' = (zipWith . zipWith) (++) all' = add' blocks' $ add' rows' cols' rows' = rows sudoku cols' = columns sudoku blocks' = fmap concat \u003c$\u003e blocks sudoku and alternate way would to see this would be if Suodku was parametrized\ngetAllValues :: Sudoku -\u003e Sudoku [Int] this tells us that each sudoku element is an array of integers.\nand by this scenario, we can easily validate sudoku if all the elements of sudoku contain exactly 9 values\n-- src/lib.hs valid :: Sudoku -\u003e Bool valid sudoku = (all . all) (== 9) (fmap length \u003c$\u003e getAllValues sudoku) Sudoku Solutions getting solutions without context The easiest solution would be to try 1 to 9 values for each 0 in the sudoku. the time complexity of this would be 9^n where n is the number of 0 in the sudoku. We already know that this solution is very slow, and we will never get any answer. But let’s see how it would be implemented in haskell.\nfirst, we need a helper function that would give us all possible values for each element:\n-- src/Lib.hs possibilities :: Cell -\u003e [Cell] possibilities 0 = [1 .. 9] possibilities n = [n] then we need a way to cross-produce each possibility. Here cross-product is the same as the cross-product of a set in mathematics.\nghci\u003e crossProduct [[1, 2, 3], [4, 5], [6]] [[1,4,6],[1,5,6],[2,4,6],[2,5,6],[3,4,6],[3,5,6]] and here is its implementation:\n-- src/Lib.hs crossProduct :: [[a]] -\u003e [[a]] crossProduct [] = [] crossProduct [a] = [[x] | x \u003c- a] crossProduct (array : rest) = (:) \u003c$\u003e array \u003c*\u003e crossProduct rest So by getting a cross-product of each possibility we will get all solutions available.\n-- src/Lib.hs getSolutions :: Sudoku -\u003e [Sudoku] getSolutions sudoku = filter valid allSudokus where allSudokus = crossProduct (crossProduct . fmap possibilities \u003c$\u003e sudoku) so for this kind of solution, we have these many possibilities:\nghci\u003e product $ fmap product $ fmap (length . possibilities) \u003c$\u003e sudoku 8599843895832833305 Which is a lot…\ngetting solutions based on context now, we can be smarter about this and only generate possibilities which are not already present in the row, column and grid blocks.\n-- src/Lib.hs possibilitiesWithContext :: Sudoku -\u003e Coord -\u003e [Cell] possibilitiesWithContext sudoku coord = if currentValue == 0 then possibleValues else [currentValue] where (x, y) = coord currentValue = head $ concat $ slice2D sudoku x (x + 1) y (y + 1) -- sudoku !! x !! y allValues' = getAllValues sudoku allValues = concatMap concat $ slice2D allValues' x (x + 1) y (y + 1) possibleValues = [0..sudokuSize] \\\\ allValues -- subtract a from b | `a` \\\\ `b` and will be plugging it in the getSolutions approach.\n-- src/Lib.hs getSolutions :: Sudoku -\u003e [Sudoku] getSolutions sudoku = filter valid allSudokus where possibilities' = possibilitiesWithContext sudoku allSudokus = crossProduct (crossProduct . fmap possibilities' \u003c$\u003e coordinates) ghci\u003e product $ fmap product $ fmap (length . possibilities') \u003c$\u003e coordinates 2972033482752 for this solution, almost 1000000 times fewer searches have to be done for this; but still slow for our computer.\ngenerating solutions based on context We can have a faster solution if for each coordinate with 0 we take one possible number and try to generate possibilities for other holes in the sudoku, if at some point we reach a hole in the sudoku where there is no possible number, then we backtrack to the previous hole and try next possibility, once we are done will all the holes in the sudoku, we return our solution.\nfor this approach, we would need a helper function that would replace our sudoku with given coordinates and a new value.\n-- src/Lib.hs replaceAt :: Int -\u003e (a -\u003e a) -\u003e [a] -\u003e [a] -- works for 1D array replaceAt index f array = left ++ (f current : right') where (left, right) = splitAt index array current = head right right' = tail right and so finally our solution\n-- src/Lib.hs generateSudoku :: [Coord] -\u003e Sudoku -\u003e [Sudoku] generateSudoku [] sudoku' = do guard (valid sudoku') return sudoku' generateSudoku (coord: coords) sudoku' = do let (x, y) = coord let values = possibilitiesWithContext sudoku' coord guard $ (not . null) values val \u003c- values let sudoku'' = replaceAt x (replaceAt y (const val)) sudoku' generateSudoku coords sudoku'' Let’s break it down. coords is a list of coordinates where we have holes = 0. generateSudoku is a function that will try to replace coord with a possibility and will backtrack if no possibility is present at some point using guard.\nand let’s plug it into our solution\n-- src/Lib.hs getSolutions :: Sudoku -\u003e [Sudoku] getSolutions sudoku = generateSudoku coords' sudoku where coords' = concatMap (fmap filter id ifValid) coordinates -- concat $ (fmap.fmap filter id) ifValid coordinates ifValid (x, y) = 0 == (sudoku !! x !! y) Printing all solutions so finally our main function looks like:\n-- app/Main.hs main :: IO () main = do sudoku \u003c- replicateM sudokuSize readRow mapM_ (putStrLn . showSudoku) $ getSolutions sudoku and our solution is\n9 2 6 3 4 5 7 8 1 8 5 1 7 2 6 4 3 9 4 7 3 8 9 1 5 2 6 5 6 8 9 1 3 2 4 7 3 4 2 6 8 7 1 9 5 1 9 7 2 5 4 8 6 3 6 8 5 4 7 9 3 1 2 7 3 4 1 6 2 9 5 8 2 1 9 5 3 8 6 7 4 ","wordCount":"2241","inLanguage":"en","image":"https://upendra1997.github.io/%3Cimage%20path/url%3E","datePublished":"2022-11-29T11:14:10+05:30","dateModified":"2022-11-29T11:14:10+05:30","author":{"@type":"Person","name":"Upendra Upadhyay"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://upendra1997.github.io/posts/haskell-sudoku/"},"publisher":{"@type":"Organization","name":"Blog | Upendra Upadhyay","logo":{"@type":"ImageObject","url":"https://upendra1997.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://upendra1997.github.io/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://upendra1997.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://upendra1997.github.io/archives title=archives><span>archives</span></a></li><li><a href=https://upendra1997.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://upendra1997.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://upendra1997.github.io/categories/ title=categories><span>categories</span></a></li><li><a href=https://upendra1997.github.io/resume/ title=resume><span>resume</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://upendra1997.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://upendra1997.github.io/posts/>Posts</a></div><h1 class=post-title>Haskell Sudoku</h1><div class=post-description>Desc Text.</div><div class=post-meta><span title='2022-11-29 11:14:10 +0530 +0530'>November 29, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;Upendra Upadhyay&nbsp;|&nbsp;<a href=https://github.com/upendra1997.github.io/content/posts/haskell-sudoku.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#project-structure aria-label="Project Structure">Project Structure</a></li><li><a href=#defining-types aria-label="Defining Types">Defining Types</a></li><li><a href=#config aria-label=Config>Config</a></li><li><a href=#parsing-and-printing-sudoku aria-label="Parsing and printing Sudoku">Parsing and printing Sudoku</a></li><li><a href=#validate-sudokus aria-label="Validate Sudokus">Validate Sudokus</a><ul><li><a href=#get-all-rows aria-label="get all rows">get all rows</a></li><li><a href=#get-all-columns aria-label="get all columns">get all columns</a></li><li><a href=#get-all-grid-blocks aria-label="get all grid blocks">get all grid blocks</a></li></ul></li><li><a href=#sudoku-solutions aria-label="Sudoku Solutions">Sudoku Solutions</a><ul><li><a href=#getting-solutions-without-context aria-label="getting solutions without context">getting solutions without context</a></li><li><a href=#getting-solutions-based-on-context aria-label="getting solutions based on context">getting solutions based on context</a></li><li><a href=#generating-solutions-based-on-context aria-label="generating solutions based on context">generating solutions based on context</a></li></ul></li><li><a href=#printing-all-solutions aria-label="Printing all solutions">Printing all solutions</a></li></ul></div></details></div><div class=post-content><p>Last time, I mentioned that I tried to write sudoku solver in haskell and it was using too much memory and time. So I tried to solve it again and this time I was able to do it, I guess I just needed more motivation.</p><p>We will be using this file format as input to our suodku program:</p><pre tabindex=0><code>92634.7.1
.5..264.9
.7.8.1...
...9..2.7
342.....5
1.....8..
6854...12
..4..29..
.1.538.7.
</code></pre><p>and it will be represented as an array of numbers and <code>.</code> will be represented as <code>0</code>, so for our repl, the sudoku will be <code>[[Int]]</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>[[<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>9</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>7</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>0</span>]]
</span></span></code></pre></div><p>above sudoku only have one solution, but there could be sudokus with multiple solutions also, like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>[[<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>1</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],  <span style=color:#75715e>-- 2 7</span>
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>3</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>5</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>9</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>9</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]]  <span style=color:#75715e>-- 7 2</span>
</span></span></code></pre></div><p>or we could have empty sudoku, which will give us all the valid sudokus possible in the world:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span>[[<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>],
</span></span><span style=display:flex><span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]]
</span></span></code></pre></div><h2 id=project-structure>Project Structure<a hidden class=anchor aria-hidden=true href=#project-structure>#</a></h2><p>This is created by using <code>stack new suokdu</code></p><pre tabindex=0><code>.
├── CHANGELOG.md
├── LICENSE
├── README.md
├── Setup.hs
├── app
│   └── Main.hs
├── emptySudoku.txt   -- empty sudoku input file.
├── package.yaml
├── src
│   └── Lib.hs
├── stack.yaml
├── stack.yaml.lock
├── sudoku.cabal
├── sudoku.txt        -- only one solution sudoku file.
└── test
    └── Spec.hs
</code></pre><h2 id=defining-types>Defining Types<a hidden class=anchor aria-hidden=true href=#defining-types>#</a></h2><p>here we will be defining a few of the types which will be used in our program, all of them are type aliases <code>type</code> instead of <code>newtype</code> as I wanted to use these types interchangeably with generic functions like <code>crossProduct</code>, which we will see later.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Cell</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>SudokuSize</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Row</span> <span style=color:#f92672>=</span> [<span style=color:#66d9ef>Int</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>X</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Y</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Coord</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>X</span>, <span style=color:#66d9ef>Y</span>) <span style=color:#75715e>-- Coordinates</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>=</span> [<span style=color:#66d9ef>Row</span>]
</span></span></code></pre></div><h2 id=config>Config<a hidden class=anchor aria-hidden=true href=#config>#</a></h2><p>We will be storing some configs like <code>sudokuSize</code> and the <code>gridSize</code> in the Sudoku in the <code>Lib.hs</code> file.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sudokuSize</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>SudokuSize</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>sudokuSize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>9</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blockSize</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blockSize</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>3</span>
</span></span></code></pre></div><h2 id=parsing-and-printing-sudoku>Parsing and printing Sudoku<a hidden class=anchor aria-hidden=true href=#parsing-and-printing-sudoku>#</a></h2><p>We need to pretty print our sudoku in the terminal, so for that, we will be defining <code>showSudoku</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>showRow</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Show</span> a <span style=color:#f92672>=&gt;</span> [a] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>showRow</span> row <span style=color:#f92672>=</span> unwords <span style=color:#f92672>$</span> show <span style=color:#f92672>&lt;$&gt;</span> row
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>showSudoku</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Show</span> a <span style=color:#f92672>=&gt;</span> [[a]] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>showSudoku</span> sudoku <span style=color:#f92672>=</span> unlines <span style=color:#f92672>$</span> showRow <span style=color:#f92672>&lt;$&gt;</span> sudoku
</span></span></code></pre></div><p>and to parse our sudoku from the file we will define below the functions:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- app/main.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>module</span> Main (<span style=color:#a6e22e>main</span>) <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Data.Char (<span style=color:#a6e22e>digitToInt</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Control.Monad (<span style=color:#a6e22e>replicateM</span>)
</span></span><span style=display:flex><span><span style=color:#66d9ef>import</span> Lib (<span style=color:#66d9ef>Cell</span>, <span style=color:#66d9ef>Row</span>, <span style=color:#a6e22e>sudokuSize</span>, <span style=color:#a6e22e>showSudoku</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseChar</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Cell</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseChar</span> <span style=color:#e6db74>&#39;.&#39;</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseChar</span> x <span style=color:#f92672>=</span> digitToInt x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseString</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Row</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseString</span> <span style=color:#f92672>=</span> map parseChar
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>readRow</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> <span style=color:#66d9ef>Row</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>readRow</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  row <span style=color:#f92672>&lt;-</span> parseString <span style=color:#f92672>&lt;$&gt;</span> getLine
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> length row <span style=color:#f92672>/=</span> sudokuSize
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>then</span> <span style=color:#a6e22e>error</span> <span style=color:#e6db74>&#34;row does not have the correct number of cells&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> return row
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    sudoku <span style=color:#f92672>&lt;-</span> replicateM sudokuSize readRow
</span></span><span style=display:flex><span>    mapM_ (putStrLn <span style=color:#f92672>.</span> showSudoku) [sudoku]
</span></span></code></pre></div><p>We have defined a function <code>readRow</code> which will read from <code>stdin</code> and try to parse it as a <code>Row</code>, and since <code>readRow</code> is an <code>IO</code>, i.e. it reads from the terminal, we can use <code>replicateM</code> to repeat this operation and read multiple rows from the terminal.</p><p>if we look at the type of replicateM in the <code>stack repl</code>, we will see that:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t replicateM
</span></span><span style=display:flex><span><span style=color:#a6e22e>replicateM</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Applicative</span> m <span style=color:#f92672>=&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> m a <span style=color:#f92672>-&gt;</span> m [a]
</span></span></code></pre></div><p>so here <code>(Int -> m a) -> m [a]</code> means that it will collect <code>a</code> from <code>m</code> type of computation and will return a new computation <code>m [a]</code> where all the <code>a</code> have been gathered from different computations.
i.e.
so here <code>(9 -> readRow)</code> replicateM needs a number <code>9</code> and a computation to replicate which is <code>readRow</code>, and it will return <code>IO [Row]</code> which is a sudoku.</p><p>similarly in <code>MapM</code> function, where _ will ignore the result:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t mapM
</span></span><span style=display:flex><span><span style=color:#a6e22e>mapM</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Traversable</span> t, <span style=color:#66d9ef>Monad</span> m) <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> m b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> m (t b)
</span></span><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> <span style=color:#66d9ef>:</span>t mapM_
</span></span><span style=display:flex><span><span style=color:#a6e22e>mapM_</span> <span style=color:#f92672>::</span> (<span style=color:#66d9ef>Foldable</span> t, <span style=color:#66d9ef>Monad</span> m) <span style=color:#f92672>=&gt;</span> (a <span style=color:#f92672>-&gt;</span> m b) <span style=color:#f92672>-&gt;</span> t a <span style=color:#f92672>-&gt;</span> m ()
</span></span></code></pre></div><h2 id=validate-sudokus>Validate Sudokus<a hidden class=anchor aria-hidden=true href=#validate-sudokus>#</a></h2><p>for a sudoku to be valid, each row and column must contain a number from 1 to 9 exactly once; and also there are 9 grids of size <code>3x3</code> in a <code>9x9</code> sudoku, where no number must repeat.</p><h3 id=get-all-rows>get all rows<a hidden class=anchor aria-hidden=true href=#get-all-rows>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rows</span> <span style=color:#f92672>::</span> [[a]] <span style=color:#f92672>-&gt;</span> [[[a]]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>rows</span> <span style=color:#f92672>=</span> fmap (replicate sudokuSize)
</span></span></code></pre></div><h3 id=get-all-columns>get all columns<a hidden class=anchor aria-hidden=true href=#get-all-columns>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>columns</span> <span style=color:#f92672>::</span> [[a]] <span style=color:#f92672>-&gt;</span> [[[a]]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>columns</span> <span style=color:#f92672>=</span> transpose <span style=color:#f92672>.</span> rows <span style=color:#f92672>.</span> transpose
</span></span></code></pre></div><h3 id=get-all-grid-blocks>get all grid blocks<a hidden class=anchor aria-hidden=true href=#get-all-grid-blocks>#</a></h3><p>to get all grid blocks we need to know which grid each element of sudoku belongs to, every grid has a start and end position which can be represented by <code>Coord</code> type.</p><p>Coordinates of all elements in sudoku:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>coordinates</span> <span style=color:#f92672>::</span> [[<span style=color:#66d9ef>Coord</span>]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>coordinates</span> <span style=color:#f92672>=</span> [[(r, c) <span style=color:#f92672>|</span> c <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>0</span> <span style=color:#f92672>..</span> sudokuSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]] <span style=color:#f92672>|</span> r <span style=color:#f92672>&lt;-</span> [<span style=color:#ae81ff>0</span> <span style=color:#f92672>..</span> sudokuSize <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>]]
</span></span></code></pre></div><p>block coordinate will give us the start and end position pairs of all sudoku elements.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blockCoordinates</span> <span style=color:#f92672>::</span> [[(<span style=color:#66d9ef>Coord</span>, <span style=color:#66d9ef>Coord</span>)]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>blockCoordinates</span> <span style=color:#f92672>=</span> (fmap <span style=color:#f92672>.</span> fmap) (<span style=color:#a6e22e>\</span>(x, y) <span style=color:#f92672>-&gt;</span> (start x y, end x y)) coordinates
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    start x&#39; y&#39; <span style=color:#f92672>=</span> (<span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> (x&#39; `div` blockSize), <span style=color:#ae81ff>3</span> <span style=color:#f92672>*</span> (y&#39; `div` blockSize))
</span></span><span style=display:flex><span>    end x&#39; y&#39; <span style=color:#f92672>=</span> (<span style=color:#a6e22e>\</span>(x&#39;&#39;, y&#39;&#39;) <span style=color:#f92672>-&gt;</span> (x&#39;&#39; <span style=color:#f92672>+</span> blockSize, y&#39;&#39; <span style=color:#f92672>+</span> blockSize)) <span style=color:#f92672>$</span> start x&#39; y&#39;
</span></span></code></pre></div><p>if Sudoku type was parametrized like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Sudoku</span> a <span style=color:#f92672>=</span> [[a]]
</span></span></code></pre></div><p>then we could have represented <code>blockCoordinates</code> as:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Rectangle</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>Coord</span>, <span style=color:#66d9ef>Coord</span>) <span style=color:#75715e>-- (start, end)</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blockCoordinates</span> <span style=color:#f92672>::</span> [[<span style=color:#66d9ef>Rectangle</span>]]
</span></span></code></pre></div><p>to get values from block coordinates we need a few helper functions like <code>slice</code> and <code>slice2D</code></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> [a] <span style=color:#f92672>-&gt;</span> [a]
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice</span> start end <span style=color:#f92672>=</span> drop start <span style=color:#f92672>.</span> take end
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice2D</span> <span style=color:#f92672>::</span> [[a]] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> [[a]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>slice2D</span> sudoku startRow endRow startCol endCol <span style=color:#f92672>=</span> slice startRow endRow <span style=color:#f92672>$</span> slice startCol endCol <span style=color:#f92672>&lt;$&gt;</span> sudoku
</span></span></code></pre></div><p>and finally, our function to get blocks at each coordinate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>blocks</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> [[[[<span style=color:#66d9ef>Int</span>]]]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>blocks</span> sudoku <span style=color:#f92672>=</span> (fmap <span style=color:#f92672>.</span> fmap) block blockCoordinates
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    getSlice <span style=color:#f92672>=</span> slice2D sudoku
</span></span><span style=display:flex><span>    block ((startRow, startCol), (endRow, endCol)) <span style=color:#f92672>=</span> getSlice startRow endRow startCol endCol
</span></span></code></pre></div><p>to understand it better, lets take our previous case where Sudoku was parametrized, which would give us</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>blocks</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Sudoku</span> (<span style=color:#66d9ef>Sudoku</span> <span style=color:#66d9ef>Int</span>)
</span></span></code></pre></div><p>here blocks is like a sudoku of sudokus, where inner sudoku is a <code>3x3</code> grid.</p><p>finally, we merge all the values of the rows, column and grid values at each coordinate of the grid and we get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>getAllValues</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> [[[<span style=color:#66d9ef>Cell</span>]]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>getAllValues</span> sudoku <span style=color:#f92672>=</span> (fmap <span style=color:#f92672>.</span> fmap) (sort <span style=color:#f92672>.</span> nub) all&#39;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    add&#39; <span style=color:#f92672>=</span> (zipWith <span style=color:#f92672>.</span> zipWith) (<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>    all&#39; <span style=color:#f92672>=</span> add&#39; blocks&#39; <span style=color:#f92672>$</span> add&#39; rows&#39; cols&#39;
</span></span><span style=display:flex><span>    rows&#39; <span style=color:#f92672>=</span> rows sudoku
</span></span><span style=display:flex><span>    cols&#39; <span style=color:#f92672>=</span> columns sudoku
</span></span><span style=display:flex><span>    blocks&#39; <span style=color:#f92672>=</span> fmap concat <span style=color:#f92672>&lt;$&gt;</span> blocks sudoku
</span></span></code></pre></div><p>and alternate way would to see this would be if <code>Suodku</code> was parametrized</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>getAllValues</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Sudoku</span> [<span style=color:#66d9ef>Int</span>]
</span></span></code></pre></div><p>this tells us that each sudoku element is an array of integers.</p><p>and by this scenario, we can easily validate sudoku if all the elements of sudoku contain exactly 9 values</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>valid</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>valid</span> sudoku <span style=color:#f92672>=</span> (all <span style=color:#f92672>.</span> all) (<span style=color:#f92672>==</span> <span style=color:#ae81ff>9</span>) (fmap length <span style=color:#f92672>&lt;$&gt;</span> getAllValues sudoku)
</span></span></code></pre></div><h2 id=sudoku-solutions>Sudoku Solutions<a hidden class=anchor aria-hidden=true href=#sudoku-solutions>#</a></h2><h3 id=getting-solutions-without-context>getting solutions without context<a hidden class=anchor aria-hidden=true href=#getting-solutions-without-context>#</a></h3><p>The easiest solution would be to try 1 to 9 values for each 0 in the sudoku.
the time complexity of this would be <code>9^n</code> where n is the number of 0 in the sudoku.
We already know that this solution is very slow, and we will never get any answer.
But let&rsquo;s see how it would be implemented in haskell.</p><p>first, we need a helper function that would give us all possible values for each element:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>possibilities</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Cell</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Cell</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>possibilities</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span> <span style=color:#f92672>..</span> <span style=color:#ae81ff>9</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>possibilities</span> n <span style=color:#f92672>=</span> [n]
</span></span></code></pre></div><p>then we need a way to cross-produce each possibility.
Here cross-product is the same as the cross-product of a set in mathematics.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> crossProduct [[<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>], [<span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>], [<span style=color:#ae81ff>6</span>]]
</span></span><span style=display:flex><span>[[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>1</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>2</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>4</span>,<span style=color:#ae81ff>6</span>],[<span style=color:#ae81ff>3</span>,<span style=color:#ae81ff>5</span>,<span style=color:#ae81ff>6</span>]]
</span></span></code></pre></div><p>and here is its implementation:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>crossProduct</span> <span style=color:#f92672>::</span> [[a]] <span style=color:#f92672>-&gt;</span> [[a]]
</span></span><span style=display:flex><span><span style=color:#a6e22e>crossProduct</span> <span style=color:#66d9ef>[]</span>             <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>crossProduct</span> [a]            <span style=color:#f92672>=</span> [[x] <span style=color:#f92672>|</span> x <span style=color:#f92672>&lt;-</span> a]
</span></span><span style=display:flex><span><span style=color:#a6e22e>crossProduct</span> (array <span style=color:#66d9ef>:</span> rest) <span style=color:#f92672>=</span> (<span style=color:#66d9ef>:</span>) <span style=color:#f92672>&lt;$&gt;</span> array <span style=color:#f92672>&lt;*&gt;</span> crossProduct rest
</span></span></code></pre></div><p>So by getting a cross-product of each possibility we will get all solutions available.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>getSolutions</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Sudoku</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>getSolutions</span> sudoku <span style=color:#f92672>=</span> filter valid allSudokus
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    allSudokus <span style=color:#f92672>=</span> crossProduct (crossProduct <span style=color:#f92672>.</span> fmap possibilities <span style=color:#f92672>&lt;$&gt;</span> sudoku)
</span></span></code></pre></div><p>so for this kind of solution, we have these many possibilities:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> product <span style=color:#f92672>$</span> fmap product <span style=color:#f92672>$</span> fmap (length <span style=color:#f92672>.</span> possibilities) <span style=color:#f92672>&lt;$&gt;</span> sudoku
</span></span><span style=display:flex><span><span style=color:#ae81ff>8599843895832833305</span>
</span></span></code></pre></div><p>Which is a lot&mldr;</p><h3 id=getting-solutions-based-on-context>getting solutions based on context<a hidden class=anchor aria-hidden=true href=#getting-solutions-based-on-context>#</a></h3><p>now, we can be smarter about this and only generate possibilities which are not already present in the row, column and grid blocks.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>possibilitiesWithContext</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Coord</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Cell</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>possibilitiesWithContext</span> sudoku coord <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> currentValue <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> <span style=color:#66d9ef>then</span> possibleValues <span style=color:#66d9ef>else</span> [currentValue]
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span> (x, y) <span style=color:#f92672>=</span> coord
</span></span><span style=display:flex><span>        currentValue <span style=color:#f92672>=</span> head <span style=color:#f92672>$</span> concat <span style=color:#f92672>$</span> slice2D sudoku x (x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) y (y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)                          <span style=color:#75715e>-- sudoku !! x !! y</span>
</span></span><span style=display:flex><span>        allValues&#39; <span style=color:#f92672>=</span> getAllValues sudoku
</span></span><span style=display:flex><span>        allValues <span style=color:#f92672>=</span> concatMap concat <span style=color:#f92672>$</span> slice2D allValues&#39; x (x <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) y (y <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        possibleValues <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span><span style=color:#f92672>..</span>sudokuSize] <span style=color:#f92672>\\</span> allValues                                              <span style=color:#75715e>-- subtract a from b | `a` \\ `b`</span>
</span></span></code></pre></div><p>and will be plugging it in the getSolutions approach.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>getSolutions</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Sudoku</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>getSolutions</span> sudoku <span style=color:#f92672>=</span> filter valid allSudokus
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span>
</span></span><span style=display:flex><span>    possibilities&#39; <span style=color:#f92672>=</span> possibilitiesWithContext sudoku
</span></span><span style=display:flex><span>    allSudokus <span style=color:#f92672>=</span> crossProduct (crossProduct <span style=color:#f92672>.</span> fmap possibilities&#39; <span style=color:#f92672>&lt;$&gt;</span> coordinates)
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>ghci</span><span style=color:#f92672>&gt;</span> product <span style=color:#f92672>$</span> fmap product <span style=color:#f92672>$</span> fmap (length <span style=color:#f92672>.</span> possibilities&#39;) <span style=color:#f92672>&lt;$&gt;</span> coordinates
</span></span><span style=display:flex><span><span style=color:#ae81ff>2972033482752</span>
</span></span></code></pre></div><p>for this solution, almost 1000000 times fewer searches have to be done for this; but still slow for our computer.</p><h3 id=generating-solutions-based-on-context>generating solutions based on context<a hidden class=anchor aria-hidden=true href=#generating-solutions-based-on-context>#</a></h3><p>We can have a faster solution if for each coordinate with <code>0</code> we take one possible number and try to generate possibilities for other holes in the sudoku, if at some point we reach a hole in the sudoku where there is no possible number, then we <strong>backtrack</strong> to the previous hole and try next possibility, once we are done will all the holes in the sudoku, we return our solution.</p><p>for this approach, we would need a helper function that would replace our sudoku with given coordinates and a new value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>replaceAt</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Int</span> <span style=color:#f92672>-&gt;</span> (a <span style=color:#f92672>-&gt;</span> a) <span style=color:#f92672>-&gt;</span> [a] <span style=color:#f92672>-&gt;</span> [a]                <span style=color:#75715e>-- works for 1D array</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>replaceAt</span> index f array <span style=color:#f92672>=</span> left <span style=color:#f92672>++</span> (f current <span style=color:#66d9ef>:</span> right&#39;)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span> (left, right) <span style=color:#f92672>=</span> splitAt index array
</span></span><span style=display:flex><span>        current <span style=color:#f92672>=</span> head right
</span></span><span style=display:flex><span>        right&#39; <span style=color:#f92672>=</span> tail right
</span></span></code></pre></div><p>and so finally our solution</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>generateSudoku</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Coord</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Sudoku</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>generateSudoku</span> <span style=color:#66d9ef>[]</span> sudoku&#39; <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>          guard (valid sudoku&#39;)
</span></span><span style=display:flex><span>          return sudoku&#39;
</span></span><span style=display:flex><span><span style=color:#a6e22e>generateSudoku</span> (coord<span style=color:#66d9ef>:</span> coords) sudoku&#39; <span style=color:#f92672>=</span>  <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> (x, y) <span style=color:#f92672>=</span> coord
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> values <span style=color:#f92672>=</span> possibilitiesWithContext sudoku&#39; coord
</span></span><span style=display:flex><span>  guard <span style=color:#f92672>$</span> (not <span style=color:#f92672>.</span> null) values
</span></span><span style=display:flex><span>  val <span style=color:#f92672>&lt;-</span> values
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>let</span> sudoku&#39;&#39; <span style=color:#f92672>=</span> replaceAt x (replaceAt y (const val)) sudoku&#39;
</span></span><span style=display:flex><span>  generateSudoku coords sudoku&#39;&#39;
</span></span></code></pre></div><p>Let&rsquo;s break it down.
<code>coords</code> is a list of coordinates where we have holes = <code>0</code>.
<code>generateSudoku</code> is a function that will try to replace <code>coord</code> with a possibility and will backtrack if no possibility is present at some point using <code>guard</code>.</p><p>and let&rsquo;s plug it into our solution</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- src/Lib.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>getSolutions</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Sudoku</span> <span style=color:#f92672>-&gt;</span> [<span style=color:#66d9ef>Sudoku</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>getSolutions</span> sudoku <span style=color:#f92672>=</span> generateSudoku coords&#39; sudoku
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>where</span> coords&#39; <span style=color:#f92672>=</span> concatMap (fmap filter id ifValid) coordinates <span style=color:#75715e>-- concat $ (fmap.fmap filter id) ifValid coordinates</span>
</span></span><span style=display:flex><span>        ifValid (x, y) <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>==</span> (sudoku <span style=color:#f92672>!!</span> x <span style=color:#f92672>!!</span> y)
</span></span></code></pre></div><h2 id=printing-all-solutions>Printing all solutions<a hidden class=anchor aria-hidden=true href=#printing-all-solutions>#</a></h2><p>so finally our main function looks like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#75715e>-- app/Main.hs</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    sudoku <span style=color:#f92672>&lt;-</span> replicateM sudokuSize readRow
</span></span><span style=display:flex><span>    mapM_ (putStrLn <span style=color:#f92672>.</span> showSudoku) <span style=color:#f92672>$</span> getSolutions sudoku
</span></span></code></pre></div><p>and our solution is</p><pre tabindex=0><code>9 2 6 3 4 5 7 8 1
8 5 1 7 2 6 4 3 9
4 7 3 8 9 1 5 2 6
5 6 8 9 1 3 2 4 7
3 4 2 6 8 7 1 9 5
1 9 7 2 5 4 8 6 3
6 8 5 4 7 9 3 1 2
7 3 4 1 6 2 9 5 8
2 1 9 5 3 8 6 7 4
</code></pre><hr></div><footer class=post-footer><ul class=post-tags><li><a href=https://upendra1997.github.io/tags/first/>first</a></li></ul><nav class=paginav><a class=next href=https://upendra1997.github.io/posts/nim-clojure-similarity/><span class=title>Next »</span><br><span>Nim Clojure Similarity</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Haskell Sudoku on twitter" href="https://twitter.com/intent/tweet/?text=Haskell%20Sudoku&url=https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f&hashtags=first"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Haskell Sudoku on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f&title=Haskell%20Sudoku&summary=Haskell%20Sudoku&source=https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Haskell Sudoku on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f&title=Haskell%20Sudoku"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Haskell Sudoku on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Haskell Sudoku on whatsapp" href="https://api.whatsapp.com/send?text=Haskell%20Sudoku%20-%20https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Haskell Sudoku on telegram" href="https://telegram.me/share/url?text=Haskell%20Sudoku&url=https%3a%2f%2fupendra1997.github.io%2fposts%2fhaskell-sudoku%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer><div id=disqus_thread></div><script type=application/javascript>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//upendra1997-github-io.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://upendra1997.github.io/>Blog | Upendra Upadhyay</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>