[{"content":"Last time, I mentioned that I tried to write sudoku solver in haskell and it was using too much memory and time. So I tried to solve it again and this time I was able to do it, I guess I just needed more motivation.\nWe will be using this file format as input to our suodku program:\n92634.7.1 .5..264.9 .7.8.1... ...9..2.7 342.....5 1.....8.. 6854...12 ..4..29.. .1.538.7. and it will be represented as an array of numbers and . will be represented as 0, so for our repl, the sudoku will be [[Int]]\n[[9, 2, 6, 3, 4, 0, 7, 0, 1], [0, 5, 0, 0, 2, 6, 4, 0, 9], [0, 7, 0, 8, 0, 1, 0, 0, 0], [0, 0, 0, 9, 0, 0, 2, 0, 7], [3, 4, 2, 0, 0, 0, 0, 0, 5], [1, 0, 0, 0, 0, 0, 8, 0, 0], [6, 8, 5, 4, 0, 0, 0, 1, 2], [0, 0, 4, 0, 0, 2, 9, 0, 0], [0, 1, 0, 5, 3, 8, 0, 7, 0]] above sudoku only have one solution, but there could be sudokus with multiple solutions also, like:\n[[2, 9, 5, 7, 4, 3, 8, 6, 1], [4, 3, 1, 8, 6, 5, 9, 0, 0], -- 2 7 [8, 7, 6, 1, 9, 2, 5, 4, 3], [3, 8, 7, 4, 5, 9, 2, 1, 6], [6, 1, 2, 3, 8, 7, 4, 9, 5], [5, 4, 9, 2, 1, 6, 7, 3, 8], [7, 6, 3, 5, 2, 4, 1, 8, 9], [9, 2, 8, 6, 7, 1, 3, 5, 4], [1, 5, 4, 9, 3, 8, 6, 0, 0]] -- 7 2 or we could have empty sudoku, which will give us all the valid sudokus possible in the world:\n[[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]] Project Structure This is created by using stack new suokdu\n. ├── CHANGELOG.md ├── LICENSE ├── README.md ├── Setup.hs ├── app │ └── Main.hs ├── emptySudoku.txt -- empty sudoku input file. ├── package.yaml ├── src │ └── Lib.hs ├── stack.yaml ├── stack.yaml.lock ├── sudoku.cabal ├── sudoku.txt -- only one solution sudoku file. └── test └── Spec.hs Defining Types here we will be defining a few of the types which will be used in our program, all of them are type aliases type instead of newtype as I wanted to use these types interchangeably with generic functions like crossProduct, which we will see later.\n-- src/Lib.hs type Cell = Int type SudokuSize = Int type Row = [Int] type X = Int type Y = Int type Coord = (X, Y) -- Coordinates type Sudoku = [Row] Config We will be storing some configs like sudokuSize and the gridSize in the Sudoku in the Lib.hs file.\n-- src/Lib.hs sudokuSize :: SudokuSize sudokuSize = 9 blockSize :: Int blockSize = 3 Parsing and printing Sudoku We need to pretty print our sudoku in the terminal, so for that, we will be defining showSudoku function:\n-- src/Lib.hs showRow :: Show a =\u0026gt; [a] -\u0026gt; String showRow row = unwords $ show \u0026lt;$\u0026gt; row showSudoku :: Show a =\u0026gt; [[a]] -\u0026gt; String showSudoku sudoku = unlines $ showRow \u0026lt;$\u0026gt; sudoku and to parse our sudoku from the file we will define below the functions:\n-- app/main.hs module Main (main) where import Data.Char (digitToInt) import Control.Monad (replicateM) import Lib (Cell, Row, sudokuSize, showSudoku) parseChar :: Char -\u0026gt; Cell parseChar \u0026#39;.\u0026#39; = 0 parseChar x = digitToInt x parseString :: String -\u0026gt; Row parseString = map parseChar readRow :: IO Row readRow = do row \u0026lt;- parseString \u0026lt;$\u0026gt; getLine if length row /= sudokuSize then error \u0026#34;row does not have the correct number of cells\u0026#34; else return row main :: IO () main = do sudoku \u0026lt;- replicateM sudokuSize readRow mapM_ (putStrLn . showSudoku) [sudoku] We have defined a function readRow which will read from stdin and try to parse it as a Row, and since readRow is an IO, i.e. it reads from the terminal, we can use replicateM to repeat this operation and read multiple rows from the terminal.\nif we look at the type of replicateM in the stack repl, we will see that:\nghci\u0026gt; :t replicateM replicateM :: Applicative m =\u0026gt; Int -\u0026gt; m a -\u0026gt; m [a] so here (Int -\u0026gt; m a) -\u0026gt; m [a] means that it will collect a from m type of computation and will return a new computation m [a] where all the a have been gathered from different computations. i.e. so here (9 -\u0026gt; readRow) replicateM needs a number 9 and a computation to replicate which is readRow, and it will return IO [Row] which is a sudoku.\nsimilarly in MapM function, where _ will ignore the result:\nghci\u0026gt; :t mapM mapM :: (Traversable t, Monad m) =\u0026gt; (a -\u0026gt; m b) -\u0026gt; t a -\u0026gt; m (t b) ghci\u0026gt; :t mapM_ mapM_ :: (Foldable t, Monad m) =\u0026gt; (a -\u0026gt; m b) -\u0026gt; t a -\u0026gt; m () Validate Sudokus for a sudoku to be valid, each row and column must contain a number from 1 to 9 exactly once; and also there are 9 grids of size 3x3 in a 9x9 sudoku, where no number must repeat.\nget all rows -- src/lib.hs rows :: [[a]] -\u0026gt; [[[a]]] rows = fmap (replicate sudokuSize) get all columns -- src/lib.hs columns :: [[a]] -\u0026gt; [[[a]]] columns = transpose . rows . transpose get all grid blocks to get all grid blocks we need to know which grid each element of sudoku belongs to, every grid has a start and end position which can be represented by Coord type.\nCoordinates of all elements in sudoku:\n-- src/lib.hs coordinates :: [[Coord]] coordinates = [[(r, c) | c \u0026lt;- [0 .. sudokuSize - 1]] | r \u0026lt;- [0 .. sudokuSize - 1]] block coordinate will give us the start and end position pairs of all sudoku elements.\n-- src/lib.hs blockCoordinates :: [[(Coord, Coord)]] blockCoordinates = (fmap . fmap) (\\(x, y) -\u0026gt; (start x y, end x y)) coordinates where start x\u0026#39; y\u0026#39; = (3 * (x\u0026#39; `div` blockSize), 3 * (y\u0026#39; `div` blockSize)) end x\u0026#39; y\u0026#39; = (\\(x\u0026#39;\u0026#39;, y\u0026#39;\u0026#39;) -\u0026gt; (x\u0026#39;\u0026#39; + blockSize, y\u0026#39;\u0026#39; + blockSize)) $ start x\u0026#39; y\u0026#39; if Sudoku type was parametrized like:\ntype Sudoku a = [[a]] then we could have represented blockCoordinates as:\ntype Rectangle = (Coord, Coord) -- (start, end) blockCoordinates :: [[Rectangle]] to get values from block coordinates we need a few helper functions like slice and slice2D\n-- src/lib.hs slice :: Int -\u0026gt; Int -\u0026gt; [a] -\u0026gt; [a] slice start end = drop start . take end -- src/lib.hs slice2D :: [[a]] -\u0026gt; Int -\u0026gt; Int -\u0026gt; Int -\u0026gt; Int -\u0026gt; [[a]] slice2D sudoku startRow endRow startCol endCol = slice startRow endRow $ slice startCol endCol \u0026lt;$\u0026gt; sudoku and finally, our function to get blocks at each coordinate:\n-- src/lib.hs blocks :: Sudoku -\u0026gt; [[[[Int]]]] blocks sudoku = (fmap . fmap) block blockCoordinates where getSlice = slice2D sudoku block ((startRow, startCol), (endRow, endCol)) = getSlice startRow endRow startCol endCol to understand it better, lets take our previous case where Sudoku was parametrized, which would give us\nblocks :: Sudoku -\u0026gt; Sudoku (Sudoku Int) here blocks is like a sudoku of sudokus, where inner sudoku is a 3x3 grid.\nfinally, we merge all the values of the rows, column and grid values at each coordinate of the grid and we get:\n-- src/lib.hs getAllValues :: Sudoku -\u0026gt; [[[Cell]]] getAllValues sudoku = (fmap . fmap) (sort . nub) all\u0026#39; where add\u0026#39; = (zipWith . zipWith) (++) all\u0026#39; = add\u0026#39; blocks\u0026#39; $ add\u0026#39; rows\u0026#39; cols\u0026#39; rows\u0026#39; = rows sudoku cols\u0026#39; = columns sudoku blocks\u0026#39; = fmap concat \u0026lt;$\u0026gt; blocks sudoku and alternate way would to see this would be if Suodku was parametrized\ngetAllValues :: Sudoku -\u0026gt; Sudoku [Int] this tells us that each sudoku element is an array of integers.\nand by this scenario, we can easily validate sudoku if all the elements of sudoku contain exactly 9 values\n-- src/lib.hs valid :: Sudoku -\u0026gt; Bool valid sudoku = (all . all) (== 9) (fmap length \u0026lt;$\u0026gt; getAllValues sudoku) Sudoku Solutions getting solutions without context The easiest solution would be to try 1 to 9 values for each 0 in the sudoku. the time complexity of this would be 9^n where n is the number of 0 in the sudoku. We already know that this solution is very slow, and we will never get any answer. But let\u0026rsquo;s see how it would be implemented in haskell.\nfirst, we need a helper function that would give us all possible values for each element:\n-- src/Lib.hs possibilities :: Cell -\u0026gt; [Cell] possibilities 0 = [1 .. 9] possibilities n = [n] then we need a way to cross-produce each possibility. Here cross-product is the same as the cross-product of a set in mathematics.\nghci\u0026gt; crossProduct [[1, 2, 3], [4, 5], [6]] [[1,4,6],[1,5,6],[2,4,6],[2,5,6],[3,4,6],[3,5,6]] and here is its implementation:\n-- src/Lib.hs crossProduct :: [[a]] -\u0026gt; [[a]] crossProduct [] = [] crossProduct [a] = [[x] | x \u0026lt;- a] crossProduct (array : rest) = (:) \u0026lt;$\u0026gt; array \u0026lt;*\u0026gt; crossProduct rest we could also use the sequence function from Prelude, which does the same thing.\nghci\u0026gt; :t sequence sequence :: (Traversable t, Monad m) =\u0026gt; t (m a) -\u0026gt; m (t a) ghci\u0026gt; sequence [[1,2,3], [4,5], [6]] [[1,4,6],[1,5,6],[2,4,6],[2,5,6],[3,4,6],[3,5,6]] So by getting a cross-product of each possibility we will get all solutions available.\n-- src/Lib.hs getSolutions :: Sudoku -\u0026gt; [Sudoku] getSolutions sudoku = filter valid allSudokus where allSudokus = crossProduct (crossProduct . fmap possibilities \u0026lt;$\u0026gt; sudoku) so for this kind of solution, we have these many possibilities:\nghci\u0026gt; product $ fmap product $ fmap (length . possibilities) \u0026lt;$\u0026gt; sudoku 8599843895832833305 Which is a lot\u0026hellip;\ngetting solutions based on context now, we can be smarter about this and only generate possibilities which are not already present in the row, column and grid blocks.\n-- src/Lib.hs possibilitiesWithContext :: Sudoku -\u0026gt; Coord -\u0026gt; [Cell] possibilitiesWithContext sudoku coord = if currentValue == 0 then possibleValues else [currentValue] where (x, y) = coord currentValue = head $ concat $ slice2D sudoku x (x + 1) y (y + 1) -- sudoku !! x !! y allValues\u0026#39; = getAllValues sudoku allValues = concatMap concat $ slice2D allValues\u0026#39; x (x + 1) y (y + 1) possibleValues = [0..sudokuSize] \\\\ allValues -- subtract a from b | `a` \\\\ `b` and will be plugging it in the getSolutions approach.\n-- src/Lib.hs getSolutions :: Sudoku -\u0026gt; [Sudoku] getSolutions sudoku = filter valid allSudokus where possibilities\u0026#39; = possibilitiesWithContext sudoku allSudokus = crossProduct (crossProduct . fmap possibilities\u0026#39; \u0026lt;$\u0026gt; coordinates) ghci\u0026gt; product $ fmap product $ fmap (length . possibilities\u0026#39;) \u0026lt;$\u0026gt; coordinates 2972033482752 for this solution, almost 1000000 times fewer searches have to be done for this; but still slow for our computer.\ngenerating solutions based on context We can have a faster solution if for each coordinate with 0 we take one possible number and try to generate possibilities for other holes in the sudoku, if at some point we reach a hole in the sudoku where there is no possible number, then we backtrack to the previous hole and try next possibility, once we are done will all the holes in the sudoku, we return our solution.\nfor this approach, we would need a helper function that would replace our sudoku with given coordinates and a new value.\n-- src/Lib.hs replaceAt :: Int -\u0026gt; (a -\u0026gt; a) -\u0026gt; [a] -\u0026gt; [a] -- works for 1D array replaceAt index f array = left ++ (f current : right\u0026#39;) where (left, right) = splitAt index array current = head right right\u0026#39; = tail right and so finally our solution\n-- src/Lib.hs generateSudoku :: [Coord] -\u0026gt; Sudoku -\u0026gt; [Sudoku] generateSudoku [] sudoku\u0026#39; = do guard (valid sudoku\u0026#39;) return sudoku\u0026#39; generateSudoku (coord: coords) sudoku\u0026#39; = do let (x, y) = coord let values = possibilitiesWithContext sudoku\u0026#39; coord guard $ (not . null) values val \u0026lt;- values let sudoku\u0026#39;\u0026#39; = replaceAt x (replaceAt y (const val)) sudoku\u0026#39; generateSudoku coords sudoku\u0026#39;\u0026#39; Let\u0026rsquo;s break it down. coords is a list of coordinates where we have holes = 0. generateSudoku is a function that will try to replace coord with a possibility and will backtrack if no possibility is present at some point using guard.\nand let\u0026rsquo;s plug it into our solution\n-- src/Lib.hs getSolutions :: Sudoku -\u0026gt; [Sudoku] getSolutions sudoku = generateSudoku coords\u0026#39; sudoku where coords\u0026#39; = concatMap (fmap filter id ifValid) coordinates -- concat $ (fmap.fmap filter id) ifValid coordinates ifValid (x, y) = 0 == (sudoku !! x !! y) Printing all solutions so finally our main function looks like:\n-- app/Main.hs main :: IO () main = do sudoku \u0026lt;- replicateM sudokuSize readRow mapM_ (putStrLn . showSudoku) $ getSolutions sudoku and our solution is\n9 2 6 3 4 5 7 8 1 8 5 1 7 2 6 4 3 9 4 7 3 8 9 1 5 2 6 5 6 8 9 1 3 2 4 7 3 4 2 6 8 7 1 9 5 1 9 7 2 5 4 8 6 3 6 8 5 4 7 9 3 1 2 7 3 4 1 6 2 9 5 8 2 1 9 5 3 8 6 7 4 Github Repository: https://github.com/upendra1997/sudoku-haskell\n","permalink":"https://upendra1997.github.io/posts/haskell-sudoku/","summary":"Last time, I mentioned that I tried to write sudoku solver in haskell and it was using too much memory and time. So I tried to solve it again and this time I was able to do it, I guess I just needed more motivation.\nWe will be using this file format as input to our suodku program:\n92634.7.1 .5..264.9 .7.8.1... ...9..2.7 342.....5 1.....8.. 6854...12 ..4..29.. .1.538.7. and it will be represented as an array of numbers and .","title":"Haskell Sudoku"},{"content":"Hello world, I am Upendra Upadhyay. This is my first post and I have been trying to write for a long time. I think there is no better time than now.\nI have been trying to learn Haskell for past 3 years in my free time, but was never able to code anything useful; mostly did fibonacci, sieve of eratosthenes, and sudoku - which was taking lot of memory and time because of bad pruning.\nFibonacci fib = 0:1:zipWith (+) fib (tail fib) ghci\u0026gt; take 10 fib [0,1,1,2,3,5,8,13,21,34] Sieve of eratosthenes sieve (p:ps) = p:sieve (filter (\\x -\u0026gt; x `mod` p /= 0) ps) prime = sieve [2..] ghci\u0026gt; take 10 prime [2,3,5,7,11,13,17,19,23,29] All things considered, I was never able to be productive in Haskell, But I got opportunity to work in Clojure; which allowed me to write functional code and interop with Java/Javascript. It created a bridge to Haskell, which have great ideas with steep learning curve.\nSimilar case is with Rust, I am still trying to solve Xorcism , never seem to be getting closer to solution. I think Rust have great ideas but also a bit of learning curve. This where I think Nim can become similar bridge like Clojure for Rust. It allows system programming and interop with C, C++, Javascript.\nwhich makes me curious to learn Nim.\n","permalink":"https://upendra1997.github.io/posts/nim-clojure-similarity/","summary":"Hello world, I am Upendra Upadhyay. This is my first post and I have been trying to write for a long time. I think there is no better time than now.\nI have been trying to learn Haskell for past 3 years in my free time, but was never able to code anything useful; mostly did fibonacci, sieve of eratosthenes, and sudoku - which was taking lot of memory and time because of bad pruning.","title":"Nim Clojure Similarity"}]